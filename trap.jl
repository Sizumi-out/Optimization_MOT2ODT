using StaticArrays

include("Atom.jl")          # Atom & select state in MOT + TraitLasers + control_func
include("mot.jl")           # MOT
include("LoopControler.jl") # struct for Loop Control
include("potential.jl")     # ODT potentials
include("rk4.jl")           # Runge-Kutta4 for calculation of dynamics in potential
include("trap_loop.jl")     # Loop

export v_t_from_Δω, Δω_from_v_t, T_D, T_from_v, v_from_T #, ask_relaxetion_time_len 

""" automatically generated by Github Copilot
    main(dt, t_end, u0, Atom, trapStructs;
        sampling = 1, rec_len = t_end, 
        gravity_sw = false, qs_rec_sw = true, prog_sw = true
    )

The main function for the optimization of laser cooling in a magneto-optical trap (MOT) with optical dipole force trapping (ODFT).

## Arguments
- `dt`: Time step size.
- `t_end`: End time of the simulation.
- `u0`: Initial state of the system.
- `Atom`: Atom type used in the simulation.
- `trapStructs`: Array of trap structures defining the trap configuration.

## Optional Arguments
- `sampling`: Sampling rate for recording data. Default is 1 (record every time step).
- `rec_len`: Length of the recording. Default is `t_end`.
- `gravity_sw`: Flag to enable/disable gravity. Default is `false`.
- `qs_rec_sw`: Flag to enable/disable recording of quantum state. Default is `true`.
- `prog_sw`: Flag to enable/disable progress display. Default is `true`.

## Returns
- `recorder`: Recorder object containing recorded data.

"""
function main(dt, t_end, u0, Atom, trapStructs;
        sampling = 1, rec_len = t_end, 
        gravity_sw = false, qs_rec_sw = true, prog_sw = true
    )

    sort!(trapStructs, by = priority)
    ctrler, recorder, tg = LoopStructs(dt, t_end, sampling, rec_len, gravity_sw, qs_rec_sw, prog_sw, trapStructs)
    tvxs = tvx(u0, 1)
    
    trap!(tvxs, tg, ctrler, recorder, Atom, trapStructs)

    return recorder
end